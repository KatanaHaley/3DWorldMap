"use strict";
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoJsonDataAdapter = void 0;
const Env_1 = require("@here/harp-datasource-protocol/lib/Env");
const ClipLineString_1 = require("@here/harp-geometry/lib/ClipLineString");
const harp_geoutils_1 = require("@here/harp-geoutils");
const three_1 = require("three");
const OmvUtils_1 = require("../../OmvUtils");
const DEFAULT_EXTENTS = 4 * 1024;
function convertGeometryType(type) {
    switch (type) {
        case "LineString":
            return "line";
        case "MultiLineString":
            return "line";
        case "Polygon":
            return "polygon";
        case "MultiPolygon":
            return "polygon";
        case "Point":
            return "point";
        case "MultiPoint":
            return "point";
        default:
            return "unknown";
    } // switch
}
const worldP = new three_1.Vector3();
/**
 * Converts a `geoPoint` to local tile space.
 *
 * @param geoPoint - The input [[GeoPointLike]].
 * @param decodeInfo - The [[DecodeInfo]].
 * @param target - A [[VectorLike]] used as target of the converted coordinates.
 * @return A [[VectorLike]] with the converted point.
 * @hidden
 */
function convertPoint(geoPoint, decodeInfo, target) {
    harp_geoutils_1.webMercatorProjection.projectPoint(harp_geoutils_1.GeoCoordinates.fromGeoPoint(geoPoint), worldP);
    return OmvUtils_1.world2tile(DEFAULT_EXTENTS, decodeInfo, worldP, false, target);
}
function convertLineStringGeometry(coordinates, decodeInfo) {
    const untiledPositions = coordinates.map(geoPoint => {
        return harp_geoutils_1.GeoCoordinates.fromGeoPoint(geoPoint);
    });
    const positions = coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo, new three_1.Vector2()));
    return { untiledPositions, positions };
}
function convertLineGeometry(geometry, decodeInfo) {
    if (geometry.type === "LineString") {
        return [convertLineStringGeometry(geometry.coordinates, decodeInfo)];
    }
    return geometry.coordinates.map(lineString => convertLineStringGeometry(lineString, decodeInfo));
}
function signedPolygonArea(contour) {
    const n = contour.length;
    let area = 0.0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
        area += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];
    }
    return area * 0.5;
}
function convertRings(coordinates, decodeInfo) {
    const rings = coordinates.map((ring, i) => {
        const isOuterRing = i === 0;
        const isClockWise = signedPolygonArea(ring) < 0;
        const { positions } = convertLineStringGeometry(ring, decodeInfo);
        if ((isOuterRing && !isClockWise) || (!isOuterRing && isClockWise)) {
            positions.reverse();
        }
        return positions;
    });
    return { rings };
}
function convertPolygonGeometry(geometry, decodeInfo) {
    if (geometry.type === "Polygon") {
        return [convertRings(geometry.coordinates, decodeInfo)];
    }
    return geometry.coordinates.map(polygon => convertRings(polygon, decodeInfo));
}
function convertPointGeometry(geometry, decodeInfo) {
    if (geometry.type === "Point") {
        return [convertPoint(geometry.coordinates, decodeInfo, new three_1.Vector3())];
    }
    return geometry.coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo, new three_1.Vector3()));
}
class GeoJsonDataAdapter {
    constructor(m_processor, dataFilter, m_logger) {
        this.m_processor = m_processor;
        this.dataFilter = dataFilter;
        this.m_logger = m_logger;
        this.id = "GeoJsonDataAdapter";
    }
    canProcess(featureCollection) {
        return (featureCollection &&
            featureCollection.type === "FeatureCollection" &&
            Array.isArray(featureCollection.features));
    }
    process(featureCollection, decodeInfo) {
        var _a, _b;
        if (!Array.isArray(featureCollection.features) || featureCollection.features.length === 0) {
            return;
        }
        const { tileKey } = decodeInfo;
        const $level = tileKey.level;
        const $zoom = Math.max(0, tileKey.level - ((_a = this.m_processor.storageLevelOffset) !== null && _a !== void 0 ? _a : 0));
        const $layer = "geojson";
        for (const feature of featureCollection.features) {
            const $geometryType = convertGeometryType(feature.geometry.type);
            const env = new Env_1.MapEnv(Object.assign(Object.assign({}, feature.properties), { $id: (_b = feature.id) !== null && _b !== void 0 ? _b : null, $layer,
                $level,
                $zoom,
                $geometryType }));
            switch (feature.geometry.type) {
                case "LineString":
                case "MultiLineString": {
                    let geometry = convertLineGeometry(feature.geometry, decodeInfo);
                    const clippedGeometries = [];
                    const DEFAULT_BORDER = 100;
                    geometry.forEach(g => {
                        const clipped = ClipLineString_1.clipLineString(g.positions, -DEFAULT_BORDER, -DEFAULT_BORDER, DEFAULT_EXTENTS + DEFAULT_BORDER, DEFAULT_EXTENTS + DEFAULT_BORDER);
                        clipped.forEach(positions => {
                            clippedGeometries.push({ positions });
                        });
                    });
                    geometry = clippedGeometries;
                    if (geometry.length > 0) {
                        this.m_processor.processLineFeature($layer, DEFAULT_EXTENTS, clippedGeometries, env, $level);
                    }
                    break;
                }
                case "Polygon":
                case "MultiPolygon": {
                    const geometry = convertPolygonGeometry(feature.geometry, decodeInfo);
                    this.m_processor.processPolygonFeature($layer, DEFAULT_EXTENTS, geometry, env, $level);
                    break;
                }
                case "Point":
                case "MultiPoint": {
                    const geometry = convertPointGeometry(feature.geometry, decodeInfo);
                    this.m_processor.processPointFeature($layer, DEFAULT_EXTENTS, geometry, env, $level);
                    break;
                }
            }
        }
    }
}
exports.GeoJsonDataAdapter = GeoJsonDataAdapter;
//# sourceMappingURL=GeoJsonDataAdapter.js.map