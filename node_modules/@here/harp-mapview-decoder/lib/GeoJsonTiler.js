"use strict";
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoJsonTiler = void 0;
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
// @ts-ignore
const geojsonvtExport = require("geojson-vt");
// to be able to run tests on nodejs
const geojsonvt = (_a = geojsonvtExport.default) !== null && _a !== void 0 ? _a : geojsonvtExport;
const EXTENT = 4096;
// the factor used to compute the size of the buffer.
const BUFFER_FACTOR = 0.05;
// align the buffer to the next integer multiple of 2.
const BUFFER = -(-Math.ceil(EXTENT * BUFFER_FACTOR) & -2);
class GeoJsonTiler {
    constructor() {
        this.indexes = new Map();
    }
    dispose() {
        /* */
    }
    async connect() {
        return await Promise.resolve();
    }
    async registerIndex(indexId, input) {
        if (this.indexes.has(indexId)) {
            return;
        }
        return await this.updateIndex(indexId, input);
    }
    async updateIndex(indexId, input) {
        if (input instanceof URL) {
            const response = await fetch(input.href);
            if (!response.ok) {
                throw new Error(`GeoJsonTiler: Unable to fetch ${input.href}: ${response.statusText}`);
            }
            input = (await response.json());
        }
        else {
            input = input;
        }
        // Generate ids only if input doesn't have them.
        const generateId = harp_datasource_protocol_1.isFeatureGeometry(input) ||
            input.type === "GeometryCollection" ||
            (input.type === "Feature" && input.id === undefined) ||
            (input.type === "FeatureCollection" &&
                input.features.length > 0 &&
                input.features[0].id === undefined);
        const index = geojsonvt(input, {
            maxZoom: 20,
            indexMaxZoom: 5,
            indexMaxPoints: 100000,
            tolerance: 3,
            extent: EXTENT,
            buffer: BUFFER,
            lineMetrics: false,
            promoteId: null,
            generateId,
            debug: 0 // logging level (0, 1 or 2)
        });
        index.geojson = input;
        this.indexes.set(indexId, index);
    }
    async getTile(indexId, tileKey) {
        const index = this.indexes.get(indexId);
        if (index === undefined) {
            throw new Error("Tile not found");
        }
        const tile = index.getTile(tileKey.level, tileKey.column, tileKey.row);
        if (tile !== null) {
            tile.layer = indexId;
        }
        return tile || {};
    }
}
exports.GeoJsonTiler = GeoJsonTiler;
//# sourceMappingURL=GeoJsonTiler.js.map