"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileDataSource = exports.TileFactory = void 0;
const harp_mapview_1 = require("@here/harp-mapview");
const ThemeLoader_1 = require("@here/harp-mapview/lib/ThemeLoader");
const harp_utils_1 = require("@here/harp-utils");
const TileLoader_1 = require("./TileLoader");
/**
 * Templated factory class to create instances of [[Tile]].
 */
class TileFactory {
    /**
     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is
     * created.
     *
     * @param m_modelConstructor - Constructor of (subclass of) [[Tile]].
     */
    constructor(m_modelConstructor) {
        this.m_modelConstructor = m_modelConstructor;
    }
    /**
     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments
     * to the constructor of [[Tile]].
     *
     * @param dataSource - [[Datasource]] this class belongs to.
     * @param tileKey - Quadtree address of the [[Tile]].
     */
    create(dataSource, tileKey) {
        const tile = new this.m_modelConstructor(dataSource, tileKey);
        tile.tileLoader = new TileLoader_1.TileLoader(dataSource, tileKey, dataSource.dataProvider(), dataSource.decoder);
        return tile;
    }
}
exports.TileFactory = TileFactory;
/**
 * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the
 * tile content asynchronously. The decoder can be passed in as an option, or a default
 * asynchronous one is generated.
 */
class TileDataSource extends harp_mapview_1.DataSource {
    /**
     * Set up the `TileDataSource`.
     *
     * @param m_tileFactory - Factory to create the [[Tile]] instances.
     * @param m_options - Options specifying the parameters of the [[DataSource]].
     */
    constructor(m_tileFactory, m_options) {
        var _a, _b;
        super(m_options);
        this.m_tileFactory = m_tileFactory;
        this.m_options = m_options;
        this.logger = harp_utils_1.LoggerManager.instance.create("TileDataSource");
        this.m_isReady = false;
        if (m_options.decoder) {
            this.m_decoder = m_options.decoder;
        }
        else if (m_options.concurrentDecoderServiceName) {
            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl, m_options.concurrentDecoderWorkerCount);
        }
        else {
            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +
                `concurrentDecoderServiceName`);
        }
        this.useGeometryLoader = true;
        this.cacheable = true;
        this.m_unregisterClearTileCache = (_b = (_a = this.dataProvider()).onDidInvalidate) === null || _b === void 0 ? void 0 : _b.call(_a, () => this.mapView.markTilesDirty(this));
    }
    /** @override */
    dispose() {
        var _a;
        (_a = this.m_unregisterClearTileCache) === null || _a === void 0 ? void 0 : _a.call(this);
        this.decoder.dispose();
        this.dataProvider().unregister(this);
    }
    /** @override */
    ready() {
        return this.m_isReady && this.m_options.dataProvider.ready();
    }
    /**
     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with
     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].
     */
    get decoder() {
        return this.m_decoder;
    }
    /** @override */
    async connect() {
        await Promise.all([this.m_options.dataProvider.register(this), this.m_decoder.connect()]);
        this.m_isReady = true;
        let customOptions = {};
        if (this.m_options.storageLevelOffset !== undefined) {
            customOptions = {
                storageLevelOffset: this.m_options.storageLevelOffset
            };
        }
        this.m_decoder.configure({ languages: this.languages }, customOptions);
    }
    /**
     * @override
     */
    setLanguages(languages) {
        this.languages = languages;
        this.m_decoder.configure({
            languages: this.languages
        });
        this.mapView.clearTileCache(this.name);
    }
    /**
     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.
     *
     * Applies new {@here/harp-datasource-protocol StyleSet} and definitions from theme only
     * if matching styleset (see `styleSetName` property) is found in `theme`.
     * @override
     */
    async setTheme(theme, languages) {
        // Seems superfluent, but the call to  ThemeLoader.load will resolve extends etc.
        theme = await ThemeLoader_1.ThemeLoader.load(theme);
        let styleSet;
        if (this.styleSetName !== undefined && theme.styles !== undefined) {
            styleSet = theme.styles[this.styleSetName];
        }
        if (languages !== undefined) {
            this.languages = languages;
        }
        if (styleSet !== undefined) {
            this.m_decoder.configure({
                styleSet,
                definitions: theme.definitions,
                priorities: theme.priorities,
                labelPriorities: theme.labelPriorities,
                languages
            });
            this.mapView.clearTileCache(this.name);
        }
    }
    /**
     * Get the [[DataProvider]] that has been passed in with the options.
     */
    dataProvider() {
        return this.m_options.dataProvider;
    }
    /** @override */
    getTilingScheme() {
        return this.m_options.tilingScheme;
    }
    /**
     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will
     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is
     * initialized with default copyrights, concatenated with copyrights from copyright provider of
     * this data source.
     *
     * @param tileKey - Quadtree address of the requested tile.
     * @param delayLoad - If true, the Tile will be created, but Tile.load will not be called.
     * @default false.
     * @override
     */
    getTile(tileKey, delayLoad = false) {
        const tile = this.m_tileFactory.create(this, tileKey);
        tile.copyrightInfo = this.m_options.copyrightInfo;
        if (this.m_options.copyrightProvider !== undefined) {
            this.m_options.copyrightProvider
                .getCopyrights(tile.geoBox, tileKey.level)
                .then(copyrightInfo => {
                tile.copyrightInfo =
                    tile.copyrightInfo === undefined
                        ? copyrightInfo
                        : [...tile.copyrightInfo, ...copyrightInfo];
                this.requestUpdate();
            });
        }
        if (!delayLoad) {
            tile.load();
        }
        return tile;
    }
    /**
     * Get [[TileInfo]] of a tile.
     *
     * @param tileKey - Quadtree address of the requested tile.
     * @returns A promise which will contain the [[TileInfo]] when resolved.
     */
    getTileInfo(tileKey) {
        const promise = new Promise((resolve, reject) => {
            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder);
            tileLoader.loadAndDecode().then(loaderState => {
                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {
                    resolve(tileLoader.tileInfo);
                }
                else {
                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));
                }
            });
        });
        return promise;
    }
}
exports.TileDataSource = TileDataSource;
//# sourceMappingURL=TileDataSource.js.map