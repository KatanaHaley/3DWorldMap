"use strict";
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapLineString = exports.clipLineString = void 0;
const harp_geoutils_1 = require("@here/harp-geoutils");
const harp_utils_1 = require("@here/harp-utils");
const three_1 = require("three");
/**
 * A clipping edge.
 *
 * @remarks
 * Clip lines using the Sutherland-Hodgman algorithm.
 *
 * @internal
 */
class ClipEdge {
    /**
     * Creates a clipping edge.
     *
     * @param x1 - The x coordinate of the first point of this ClipEdge.
     * @param y1 - The y coordinate of the first point of this ClipEdge.
     * @param x2 - The x coordinate of the second point of this ClipEdge.
     * @param y2 - The y coordinate of the second point of this ClipEdge.
     * @param isInside - The function used to test points against this ClipEdge.
     */
    constructor(x1, y1, x2, y2, isInside) {
        this.isInside = isInside;
        this.p0 = new three_1.Vector2(x1, y1);
        this.p1 = new three_1.Vector2(x2, y2);
    }
    /**
     * Tests if the given point is inside this clipping edge.
     */
    inside(point) {
        return this.isInside(point);
    }
    /**
     * Computes the intersection of a line and this clipping edge.
     *
     * @remarks
     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
     *    | line-line intersection}.
     */
    computeIntersection(a, b) {
        const result = new three_1.Vector2();
        harp_utils_1.Math2D.intersectLines(a.x, a.y, b.x, b.y, this.p0.x, this.p0.y, this.p1.x, this.p1.y, result);
        return result;
    }
    /**
     * Clip the input line against this edge.
     */
    clipLine(lineString) {
        const inputList = lineString;
        const result = [];
        lineString = [];
        result.push(lineString);
        const pushPoint = (point) => {
            if (lineString.length === 0 || !lineString[lineString.length - 1].equals(point)) {
                lineString.push(point);
            }
        };
        for (let i = 0; i < inputList.length; ++i) {
            const currentPoint = inputList[i];
            const prevPoint = i > 0 ? inputList[i - 1] : undefined;
            if (this.inside(currentPoint)) {
                if (prevPoint !== undefined && !this.inside(prevPoint)) {
                    if (lineString.length > 0) {
                        lineString = [];
                        result.push(lineString);
                    }
                    pushPoint(this.computeIntersection(prevPoint, currentPoint));
                }
                pushPoint(currentPoint);
            }
            else if (prevPoint !== undefined && this.inside(prevPoint)) {
                pushPoint(this.computeIntersection(prevPoint, currentPoint));
            }
        }
        if (result[result.length - 1].length === 0) {
            result.length = result.length - 1;
        }
        return result;
    }
    /**
     * Clip the input lines against this edge.
     */
    clipLines(lineStrings) {
        const reuslt = [];
        lineStrings.forEach(lineString => {
            this.clipLine(lineString).forEach(clippedLine => {
                reuslt.push(clippedLine);
            });
        });
        return reuslt;
    }
}
/**
 * Clip the input line against the given bounds.
 *
 * @param lineString - The line to clip.
 * @param minX - The minimum x coordinate.
 * @param minY - The minimum y coordinate.
 * @param maxX - The maxumum x coordinate.
 * @param maxY - The maxumum y coordinate.
 */
function clipLineString(lineString, minX, minY, maxX, maxY) {
    const clipEdge0 = new ClipEdge(minX, minY, minX, maxY, p => p.x > minX); // left
    const clipEdge1 = new ClipEdge(minX, maxY, maxX, maxY, p => p.y < maxY); // bottom
    const clipEdge2 = new ClipEdge(maxX, maxY, maxX, minY, p => p.x < maxX); // right
    const clipEdge3 = new ClipEdge(maxX, minY, minX, minY, p => p.y > minY); // top
    let lines = clipEdge0.clipLine(lineString);
    lines = clipEdge1.clipLines(lines);
    lines = clipEdge2.clipLines(lines);
    lines = clipEdge3.clipLines(lines);
    return lines;
}
exports.clipLineString = clipLineString;
/**
 * Helper function to wrap a line string projected in web mercator.
 *
 * @param multiLineString The input to wrap
 * @param edges The clipping edges used to wrap the input.
 * @param offset The x-offset used to displace the result
 *
 * @internal
 */
function wrapMultiLineStringHelper(multiLineString, edges, offset) {
    for (const clip of edges) {
        multiLineString = clip.clipLines(multiLineString);
    }
    const worldP = new three_1.Vector3();
    const coordinates = [];
    multiLineString.forEach(lineString => {
        if (lineString.length === 0) {
            return;
        }
        const coords = lineString.map(({ x, y }) => {
            worldP.set(x, y, 0);
            const geoPoint = harp_geoutils_1.webMercatorProjection.unprojectPoint(worldP);
            geoPoint.longitude += offset;
            return geoPoint;
        });
        coordinates.push(coords);
    });
    return coordinates.length > 0 ? coordinates : undefined;
}
/**
 * Wrap the given line string.
 *
 * @remarks
 * This function splits this input line string in three parts.
 *
 * The `left` member of the result contains the part of the line string with longitude less than `-180`.
 *
 * The `middle` member contains the part of the line string with longitude in the range `[-180, 180]`.
 *
 * The `right` member contains the part of the line string with longitude greater than `180`.
 *
 * @param coordinates The coordinates of the line string to wrap.
 */
function wrapLineString(coordinates) {
    const worldP = new three_1.Vector3();
    const lineString = coordinates.map(g => {
        const { x, y } = harp_geoutils_1.webMercatorProjection.projectPoint(g, worldP);
        return new three_1.Vector2(x, y);
    });
    const multiLineString = [lineString];
    return {
        left: wrapMultiLineStringHelper(multiLineString, WRAP_LEFT_CLIP_EDGES, 360),
        middle: wrapMultiLineStringHelper(multiLineString, WRAP_MIDDLE_CLIP_EDGES, 0),
        right: wrapMultiLineStringHelper(multiLineString, WRAP_RIGHT_CLIP_EDGES, -360)
    };
}
exports.wrapLineString = wrapLineString;
const ec = harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE;
const border = 0;
const WRAP_MIDDLE_CLIP_EDGES = [
    new ClipEdge(0 - border, ec, 0 - border, 0, p => p.x > 0 - border),
    new ClipEdge(ec + border, 0, ec + border, ec, p => p.x < ec + border)
];
const WRAP_LEFT_CLIP_EDGES = [
    new ClipEdge(-ec - border, ec, -ec - border, 0, p => p.x > -ec - border),
    new ClipEdge(0 + border, 0, 0 + border, ec, p => p.x < 0 + border)
];
const WRAP_RIGHT_CLIP_EDGES = [
    new ClipEdge(ec - border, ec, ec - border, 0, p => p.x > ec - border),
    new ClipEdge(ec * 2 + border, 0, ec * 2 + border, ec, p => p.x < ec * 2 + border)
];
//# sourceMappingURL=ClipLineString.js.map