"use strict";
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CirclePointsMaterial = void 0;
const THREE = require("three");
const RawShaderMaterial_1 = require("./RawShaderMaterial");
const Utils_1 = require("./Utils");
const vertexShader = `
uniform float size;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

attribute vec3 position;

void main() {
    vec3 transformed = vec3(position);
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
}
`;
const fragmentShader = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform float opacity;

void main() {
    float alpha = opacity;

    float radius = 0.5;
    vec2 coords = gl_PointCoord.xy - vec2(0.5);
    float len = length(coords);
    float falloff = fwidth(len);
    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);
    alpha *= threshold;

    gl_FragColor = vec4(diffuse, alpha);
}`;
/**
 * Material designed to render circle points. Note that it is always transparent since the circle
 * shape is created with an alpha channel to benefit an antialising that a mere `discard` could
 * not bring.
 */
class CirclePointsMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `CirclePointsMaterial`.
     *
     * @param parameters - The constructor's parameters. Always required except when cloning another
     */
    constructor(parameters) {
        const defaultColor = new THREE.Color();
        const defaultOpacity = 1.0;
        let sizeValue, colorValue, opacityValue;
        let shaderParameters;
        if (parameters) {
            const { size, color, opacity } = parameters, shaderParams = __rest(parameters, ["size", "color", "opacity"]);
            sizeValue = size;
            colorValue = color;
            opacityValue = opacity;
            shaderParams.name = "CirclePointsMaterial";
            shaderParams.vertexShader = vertexShader;
            shaderParams.fragmentShader = fragmentShader;
            shaderParams.uniforms = THREE.UniformsUtils.merge([
                {
                    size: new THREE.Uniform(CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),
                    diffuse: new THREE.Uniform(defaultColor),
                    opacity: new THREE.Uniform(defaultOpacity)
                },
                THREE.UniformsLib.fog
            ]);
            shaderParams.depthTest = false;
            shaderParams.extensions = Object.assign(Object.assign({}, shaderParams.extensions), { derivatives: true });
            shaderParameters = shaderParams;
        }
        super(shaderParameters);
        // Blending needs to always be enabled to support smooth edges
        Utils_1.enforceBlending(this);
        this.type = "CirclePointsMaterial";
        this.setOpacity(defaultOpacity);
        if (sizeValue !== undefined) {
            this.size = sizeValue;
        }
        if (colorValue !== undefined) {
            this.color = colorValue;
        }
        if (opacityValue !== undefined) {
            this.setOpacity(opacityValue);
        }
    }
    /**
     * Gets the circle screen size.
     */
    get size() {
        return this.uniforms.size.value;
    }
    /**
     * Sets the circle screen size.
     */
    set size(size) {
        this.uniforms.size.value = size;
    }
    get color() {
        return this.uniforms.diffuse.value;
    }
    set color(value) {
        this.uniforms.diffuse.value.copy(value);
    }
}
exports.CirclePointsMaterial = CirclePointsMaterial;
CirclePointsMaterial.DEFAULT_CIRCLE_SIZE = 1;
//# sourceMappingURL=CirclePointsMaterial.js.map