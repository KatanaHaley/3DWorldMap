"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawShaderMaterial = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = require("@here/harp-utils");
const THREE = require("three");
const Utils_1 = require("./Utils");
/**
 * Base class for all raw shader materials. Ensures WebGL2 compatibility for WebGL1 shaders.
 */
class RawShaderMaterial extends THREE.RawShaderMaterial {
    /**
     * The constructor of `RawShaderMaterial`.
     *
     * @param params - `RawShaderMaterial` parameters.  Always required except when cloning
     * another material.
     */
    constructor(params) {
        const isWebGL2 = (params === null || params === void 0 ? void 0 : params.rendererCapabilities.isWebGL2) === true;
        const shaderParams = params
            ? Object.assign(Object.assign({}, params), { glslVersion: isWebGL2 ? THREE.GLSL3 : THREE.GLSL1, vertexShader: isWebGL2 && params.vertexShader
                    ? harp_utils_1.convertVertexShaderToWebGL2(params.vertexShader)
                    : params.vertexShader, fragmentShader: isWebGL2 && params.fragmentShader
                    ? harp_utils_1.convertFragmentShaderToWebGL2(params.fragmentShader)
                    : params.fragmentShader }) : undefined;
        // Remove properties that are not in THREE.ShaderMaterialParameters, otherwise THREE.js
        // will log warnings.
        if (shaderParams) {
            delete shaderParams.rendererCapabilities;
        }
        super(shaderParams);
        this.invalidateFog();
        this.setOpacity(shaderParams === null || shaderParams === void 0 ? void 0 : shaderParams.opacity);
    }
    invalidateFog() {
        if (this.defines !== undefined && this.fog !== Utils_1.getShaderMaterialDefine(this, "USE_FOG")) {
            Utils_1.setShaderMaterialDefine(this, "USE_FOG", this.fog);
        }
    }
    /**
     * To set the material's opacity property value and also update the opacity value of the uniforms if needed.
     * @param opacity If undefined, the value is not set
     */
    setOpacity(opacity) {
        var _a;
        if (opacity !== undefined) {
            // The base constructor may set the opacity property before,
            // therefore we don't check unequality of the current and new opacity value:
            this.opacity = opacity;
            if ((_a = this.uniforms) === null || _a === void 0 ? void 0 : _a.opacity) {
                this.uniforms.opacity.value = opacity;
            }
        }
    }
}
exports.RawShaderMaterial = RawShaderMaterial;
//# sourceMappingURL=RawShaderMaterial.js.map